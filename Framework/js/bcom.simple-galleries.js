if (typeof bcom === "undefined") { bcom = {}; }


/*
 * Gallery module for Boston.com
 * by Jesse Marple based on work by Pete Karl (@steyblind)
 * Depends on: Magnific Popup, Hammer.js, Omniture, bcom.util.js
 * This module is totally dependant on CMS creating a property crafted set of objects in a json payload. The payload contains an array of objects. An object should look like this:
 {
    "slide_head": "",
    "slide_subhead": "",
    "image": "",
    "text": "",
    "credit": ""
}
 The payload is generated by CMS DIRECTLY on the WORKBENCH$configurationURI/Framework/skins/leaf/gallery/gallery_default.jpt.

 Simple Galleries is inappropriately named. This is one of the most complex portions of the site, second only to the stream.
 With Simple Galleries, we mimick an 'ajax' experience in how the gallery and subsequent images are 'loaded'. This mechanism also includes ad refreshes.

 What's really very cool about the BDC galleries is how we have ONE set of markup that with two very simple css class changes make up the three variations and two display types of the galleries. Those are: Image, Text and Split focus. The two diplay types are: Click and Scroll.



*/
bcom.galleries = (function() {
	'use strict';

	var module = {};

	// the mustache templates are located here:
	// WORKBENCH$configurationURI/Framework/skins/leaf/gallery/gallery_mustache.jpt
	// and are called from here:
	// WORKBENCH$configurationURI/Framework/skins/leaf/gallery/gallery_default.jpt
	// we capture the markup from the gallery template and stash it in a var
	module.template = $('#gallery_template').html();
	// we cappture the markup for the preview template and stash it in a var.
	module.previewTemplate = $('#gallery_preview').html();

	// unless otherwise set, we set our currentSlide to 0, which may be overwritten should a user come in to the gallery at the 'nth' slide.
	module.currentSlide = 0;

	//before running, we set our galleryType - which is used later on - to null
	module.galleryType = null;

	// we get the url hash (anything after the #) and trim any whitespace out of it.
	module.hash = window.location.hash.trim();
	// we are going to use a particular hash for our gallery, let's write it once and be able to reuse it instead of hard coding it.
	module.hashProto = '#slide-';

	//omniture behaves strangely with galleries as we are counting 'page views' for each increment of the gallery despite the page not actually refreshing. We do this by calling s.t(), the omniture call for tracking a page view. s.t() blows away other valuable vars that we will need in subsequent calls to both s.tl() and s.t(). To that end, we store some of the omniture sVars and properties in a locally scopped var, module.omniture, for safekeeping.
	module.omniture = bcom.util.saveSVars(s);

	// the first time we run galleries there are some considerations and things that must be accounted for (see way below). We set this to true for our first run through and setting up the gallery.
	module.firstFire = true;

	module.init = function(payload) {
		//we NEED payload - like a fish needs water - or this whole thing doesn't work.
		if (payload.length === 0){
			// no payload, no love.
			return;
		}

		// The current slide needs to be human readable - so our position of 0 (i.e. #slide-0) doesn't help since most people will be confused by that. This also means that when people see #slide-1 and they are actually on the second slide. In order to correct for that we artificially add 1 to the currentSlide.
		if(module.hash && module.hash.indexOf(module.hashProto) > -1 ){
			module.currentSlide = parseInt(module.hash.substring(module.hashProto.length),10)-1;
		}

		//let's start by getting our gallery type. Remember module.galleryType from above? Well, here we check and actually set what its value should be. This var is then used later in our set of functions.
		var $galleryType = $('.gallery-type');
		if($galleryType.hasClass('image-focused-gallery')){
			module.galleryType = "image-focused";
		} else if ($galleryType.hasClass('text-focused-gallery')){
			module.galleryType = "text-focused";
		} else {
			module.galleryType = "split-focused";
		};

		// Preview Modal:
		// We bind our preview modal to the magnificPopup and other related logic including Omniture.
		// TODO: A way to make this more efficient would be to only fill in the Preview modal once, not each time the preview-trigger is clicked. At the moment it loads the modal each time.
		$(document).on('click', '.preview-trigger', function(e){
			e.preventDefault();
			var that = this;
			// Open directly via API
			$.magnificPopup.open({
				type: 'inline',
				mainClass: 'mfp-zoom-in',
				removalDelay: 200,
				items: [
				{
					src: that.hash, // can be a HTML string, jQuery object, or CSS selector
					el: that
				}],
				callbacks: {
					beforeOpen: function() {
						// before we open the modal, we need to fill it with images and links to those images in our gallery.
						// TODO: This is inefficient. Find a better (read: cached) way.

						var output = Mustache.to_html(module.previewTemplate, payload);
						$('#mfp-gallery-preview .gallery-slides').html(output);
					},
					open: function(){
						// setting s to global, such that we're hitting the right reporting suite
						s = s_gi('nytbglobe,nytbgglobal');
						//omniture
				        // omniture for counting opening the preview as a page view
				        s.pageName = s.pageName + ' | Modal preview';
				        s.prop6 = s.prop6 + ' | Modal preview';

            			s.t();
            			// s.t() clears all of our eVars and s.props. This resets them.
            			bcom.util.resetSVars(module.omniture);

						// omniture for which kind of gallery the preview is being called on. This isn't the 'global' omniture, instead it is the property specific omniture.
						s = s_gi('nytbglobe');

						// Remember setting our galleryType? Now we're gonna use 'em!

						// FOR IMAGE GALLERIES
						if(module.galleryType === 'image-focused'){
							//var s=s_gi('nytbglobe');
							s.tl(this,'o','Image_Gallery_Preview_Button');
				        	//bcom.util.clearSVars(s);
				    	}
						// FOR TEXT GALLERIES
						if(module.galleryType === 'text-focused'){
							//var s=s_gi('nytbglobe');
							s.tl(this,'o','Text_Gallery_Preview_Button');
				        	//bcom.util.clearSVars(s);
				        }
						// FOR SPLIT GALLERIES
						if(module.galleryType === 'split-focused'){
							//var s=s_gi('nytbglobe');
							s.tl(this,'o','Split_Gallery_Preview_Button');
				        	//bcom.util.clearSVars(s);
				        }
						// end omniture

					},
					close: function(){

					}
				},
				midClick: true
			});
			//When the Preview modal is open, the user can select a particular image to directly navigate to. The following handles that UX.
			$(document).on('click', '#mfp-gallery-preview .gallery-img-link', function(e){
				// Since we are following a link, we need to stop its normal event.
				e.preventDefault();
				// We check to see which type of gallery we are on: click or scroll as there are different behaviors.
				if($('.gallery-type').hasClass('click-gallery')){
					// TODO: parseInt should be replaced with parseFloat as we are dealing with whole numbers already.
					// setting current slide to the associated imageId coming in off of the data attribute (data-image-id) from the mustache template generated above.
					module.currentSlide = parseInt(e.currentTarget.dataset.imageId,10);
					//see the redrawSlides function below for more information
					redrawSlides();
				} else {
					//if we aren't on a click gallery, then we are on a slide gallery. The difference here being that instead of setting module.currentSlide to a particular slide and then calling redrawSlides, we scroll to the position of the gallery slide by its ID - e.g. id="gallery-slide-3". We throw in an animation to make it looks smooth.
					var position = $('#gallery-slide-'+e.currentTarget.dataset.imageId).offset().top;
					$('html, body').animate({ scrollTop: position - 80},1000);
				};
				//omniture
				// don'tforget, this counts as a tracking link, so we call omniture s.tl()
				var s=s_gi('nytbglobe');
				s.tl(this,'o','Gallery_Modal_Preview_Image_Click');
        		//bcom.util.clearSVars(s);
        		// end omniture
        		// since we've already started moving to the position of the slide we need to close magnificPopup directly, using their API.
				$.magnificPopup.close();
			});
		});

		// Give us feedback when the user is hovering in the Lead Tease so we
		// take action in the CSS, say for showing and hiding arrows
		$(document)
			.on('mouseenter', '.swiper-mod, .gallery-body-mod', function () {
				$(this).addClass('is-hovering');
			}).on('mouseleave', '.swiper-mod, .gallery-body-mod', function () {
				$(this).removeClass('is-hovering');
			});


		// NON SWIPER GALLERIES

		// pair up keypresses with class assignment for design/testing purposes
		// 49 - 51 will switch the gallery type - image, text, split
		// 52 - 53 will switch the view type
		// 37 & 39 are the arrow keys that will navigate left and right in the gallery
		var keyObj = {
			// Key 1
			49: function() {
				$('.gallery-type').addClass('image-focused-gallery').removeClass('split-focused-gallery').removeClass('text-focused-gallery');
			},
			// Key 2
			50: function() {
				$('.gallery-type').removeClass('image-focused-gallery').addClass('split-focused-gallery').removeClass('text-focused-gallery');
			},
			// Key 3
			51: function() {
				$('.gallery-type').removeClass('image-focused-gallery').removeClass('split-focused-gallery').addClass('text-focused-gallery');
			},
			// Key 4
			52: function() {
				$('.gallery-type').removeClass('click-gallery').addClass('scrolling-gallery');
				redrawSlides();
			},
			// Key 5
			53: function() {
				$('.gallery-type').addClass('click-gallery').removeClass('scrolling-gallery');
				redrawSlides();
			},
			// Left Arrow
			37: function(e) {
				module.currentSlide--;
				redrawSlides();
			},
			// Right Arrow
			39: function(e) {
				module.currentSlide++;
				redrawSlides();
			}
		};

		// handy function that manages keystrokes as defined above. Think of the above as a schema for the function below.
		$(document).on('keydown', function(e) {
			if ($.inArray(e.which + '', Object.keys(keyObj)) >= 0) {
				keyObj[e.which]();
			}
		});

		// added swipe gestures to clickthrough galleries for touch
		// requires Hammer.js
		if(typeof Hammer !== 'undefined') {
			// console.log('Hammer exists');
			var imgNav = $('.gallery-wrapper');

			// console.log('Hammers assigned');
			// Adds swipe left gesture
			var swipeLeft = new Hammer(imgNav).on('swipeleft', function(e) {
				// moving on
				module.currentSlide++;
				redrawSlides();
			});
			// adds swipe right gesture
			var swipeRight = new Hammer(imgNav).on('swiperight', function(e) {
				// moving back
				module.currentSlide--;
				redrawSlides();
			});
		}

		// Next/Previous Buttons/Controls
		// Previous
		$(document).on('click','.prev-btn, .swiper-prev', function(e) {
			e.preventDefault();
			// make sure we aren't already at the FIRST slide
			if(module.currentSlide == 0) module.currentSlide = payload.length;
			//if(module.currentSlide>0){
        		module.currentSlide--;
        		redrawSlides();
			//}
		});
		// Next
		$(document).on('click','.next-btn, .swiper-next', function(e) {
			e.preventDefault();
			// make sure we aren't at the LAST slide
		if(module.currentSlide == payload.length - 1) module.currentSlide = -1;

			//if(module.currentSlide < payload.length - 1){
        		module.currentSlide++;
        		redrawSlides();
			//}
		});
		// The kickoff! We check to see if .gallery-wrapper even exists on the page. If so, let's show the first item.
		// TODO: This is kind of a sloppy kickoff. The check for .gallery-wrapper works just fine and calling redrawSlides() isn't bad either, its more a placement thing; this is kind of in a weird location in the JS.
		// TODO: This is repeated in the doc.ready kickoff below, so basically, we're checking for the same thing twice! THINK DRY - as in DONT REPEAT YOURSELF! FIX THIS!
		if($('.gallery-wrapper').length) {
			redrawSlides();
		}

		// Several sloppy if statements that automagically turn a click gallery into scrolling gallery if window is under 600px
		if($(window).width() < 600) {
			if($('.gallery-type').hasClass('click-gallery')){
				$('.gallery-type').removeClass('click-gallery').addClass('scrolling-gallery scrolling-gallery-fix');
				redrawSlides();
			}
		}
		// we also want to be able to expand back to the right kind of gallery if the width of the window changes
		$(window).resize(function(){
			if($(window).width() < 600) {
				if($('.gallery-type').hasClass('click-gallery')){
					$('.gallery-type').removeClass('click-gallery').addClass('scrolling-gallery scrolling-gallery-fix');
					redrawSlides();
				}
			} else if($('.gallery-type').hasClass('scrolling-gallery-fix')) {
				$('.gallery-type').addClass('click-gallery').removeClass('scrolling-gallery scrolling-gallery-fix');
				redrawSlides();
			}
		});

		// we've just loaded the gallery for the first time so let's set firstFire to false thus allowing for redrawSlides to fire an omniture request on subsequent views
		module.firstFire = false;
	};

	function redrawSlides() {
		//You've already met redrawSlides() a few times above. It is the heart and soul of the gallery javascript.

		// set a var to contain the .gallery-type element
		var $galleryType = $('.gallery-type');

		// // The magic that activate/deactives the prev/next buttons
		// if  ((module.currentSlide + 1) === 1){
		// 	// we are on the current slide
		// 	$(".prev-btn").addClass('inactive-slide-btn');
		// } else if ((module.currentSlide + 1) === payload.length){
		// 	// we are on the last slide
		// 	$(".next-btn").addClass('inactive-slide-btn');
		// } else {
		// 	$(".prev-btn").removeClass('inactive-slide-btn');
		// 	$(".next-btn").removeClass('inactive-slide-btn');
		// }

		if($galleryType.hasClass('click-gallery')){

			// Refresh Omniture vars
			// Notice how we are checking if s is an object (it should be) and if firstFire is false - we don't want to fire the onmiture page count - s.t() - since when the page loads the first time that is already tracked. Yay for useful vars!
			if (typeof s == 'object' && module.firstFire === false) {
				// setting s to global, such that we're hitting the right reporting suite
   				bcom.util.resetSVars(module.omniture);
				s = s_gi('nytbglobe,nytbgglobal');
				s.prop5 = module.currentSlide + 1;
				s.t();
    			// s.t() clears all of our eVars and s.props. This resets them.
    			bcom.util.resetSVars(module.omniture);
			};

			if(module.currentSlide < 0) {
				// There should be no way that we can have a negative current slide. If that happens we need to set it to 0.
				module.currentSlide = 0;
				// console.log('we are at the first slide');
			}

			// hide all slides because we don't want to show them all, only one in particular
			$('.gallery-slide').hide();

			if(module.currentSlide > (payload.length - 1)) {
				// There should be no way that we can have a currentSlide that exceeds the number of slides in a payload. If that's the case - somehow - we set the currentSlide to the last slide in the payload.
				module.currentSlide = payload.length - 1;
			}

			// This if statement adds some hash logic as well as a class
			if(module.currentSlide === 0) {
				// we are on the first slide! add a class to celebrate!
				$galleryType.addClass('first-slide');
			} else {
				// we aren't on the first slide. no bother! but we do need to add a 'slug' or hash for easy linking!
				// first, let's remove any pesky 'first-slide' classes as that ship has sailed.
				$galleryType.removeClass('first-slide');
				// humans don't understand that you start counting from 0 in an array, so we need to make the hash make sense to a person - e.g. #slide-2 is not the third slide but the second.
				// this makes use of module.hashProto that was set way up top.
				var humanReadableSlidePosition = module.currentSlide + 1;
				window.location.hash = module.hashProto + humanReadableSlidePosition;
			}
			// honestly, I don't have any idea what this does. I don't remember writing this part though it seems pretty self explanitory.
			if($galleryType.hasClass('num-descend')) {
				$('.slide-num').text( numSlides - module.currentSlide);
			} else if($galleryType.hasClass('num-ascend')) {
				$('.slide-num').text(module.currentSlide);
			}
			// Pagination - this plumbs markup with numbers
			// e.g. 1 of 10, 16 of 42, etc.
			$('.current-page').text(module.currentSlide+1);
			$('.total-pages').text(payload.length);

			// FINALLY! Now, we retrieve from payload our slide of choice and render its markup with mustache.
			var output = Mustache.to_html(module.template, payload[module.currentSlide]);
			// take that output and put it someplace usefully, like in the DOM.
			$('.story-mod .gallery-slides').html(output);

			// *** Update "Next Slide:" link - BDC-746
			var nextSlide = payload[module.currentSlide + 1] ? (module.currentSlide + 1) : 0 ;
			var nextSlideHead = payload[nextSlide].slide_head;
			if (nextSlide == 0) {
				$('#next-slide-headline').text("Return to the beginning");
			// In some blank slideheads the string still had 2 characters
			// for some reason, so I tested for any length above 2 characters
			 } else if (nextSlideHead.length > 2) {
				$('#next-slide-headline').text("Next Slide: " + nextSlideHead);
			 } else {
				$('#next-slide-headline').text("Next Slide");
			};
			// This checks to see if there is a caption for the slide
			// and if there is no caption, it hides the "Next Slide" text
			 if ($('.gallery-text-mod p').text().length == 0) {
			 	$('a.swiper-next').css("display", "none");
			 }
			// See note on limitSlideSize
			//limitSlideSize(slides[module.currentSlide]);

      if ( clickAds.loaded ) { clickAds.startRefresh(); }
      // redrawSlides() is called on DOM ready, ads are loaded
      clickAds.loaded = true;

		} else if($galleryType.hasClass('scrolling-gallery')) {

      // Merge ads with slides
			var slidesWithAds = scrollAds.merge(payload);

      // Insert template output into the page
			var output = Mustache.to_html(module.template, slidesWithAds);
			$('.story-mod .gallery-slides').html(output);

			// Show ads - see Eddie Kennedy for questions.
			scrollAds.show();

		}
	}


	function limitSlideSize(slide) {
		// This function is more or less useless - depracated even.
		// It used to be that we had all of the slides load at once - thanks UpStatement - and as such we really really really don't use this.
		// however, I kept it for posterity as this is a handy function that might be needed someday - like when you need a weapon to defeat a Sith Lord and the only thing that will do the job is an equally evil piece of technology.
		// needs to be overhauled such that its not thinking this is a dom element, slide is now an array from a payload
		var $slide = $(slide);
		var $img = $slide.find('.gallery-img');

		var windowHeight = $(window).height();
		var	imgMaxHeight = (windowHeight * 0.6);
		var	quickMaxHeight = (windowHeight * 0.6);
		var articleMaxHeight = (400);
		var newArticleHeight = articleMaxHeight * ( $img.width() / $img.height() );

		var fixedWidth;
		if ($('.gallery-type').hasClass('article-gallery')){
			fixedWidth = newArticleHeight;
			$img.css('width', fixedWidth + 'px');
		} else {
			fixedWidth = imgMaxHeight * ( $img.width() / $img.height() );
			$img.css('width', fixedWidth + 'px');
		}
	}

  // Ads business
  // If it has to do with Ads, see Eddie Kennedy
  var clickAds = {
    loaded: false,
    catalog: ['ad_lead1', 'ad_toprightslot'],
    refresh: function() {
      var definitionArray = [];
      var currentBreakPoint = bcom.util.getCurrentBreakPoint();
      $.each( clickAds.catalog, function( i, adName ) {
        if ( bcom.dfp.refreshingAds[adName] && bcom.dfp.refreshingAds[adName].adDefinition ) {
          definitionArray.push( bcom.dfp.refreshingAds[adName].adDefinition );
        }
      });
      if ( definitionArray.length > 0 ) {
        googletag.cmd.push(function() {
          googletag.pubads().setTargeting( 'breakpoint', currentBreakPoint );
          googletag.pubads().refresh( definitionArray );
        });
      }
    }
  };
  // startRefresh called on redrawSlides
  clickAds.startRefresh = _.debounce( clickAds.refresh, bcom.dfp.refreshRate );

  var scrollAds = {
    max: 20,
    count: 0,
    displayed: false,
    allAds: [],
    merge: function(slides) {
      // Loop through the slides array and push an ad object based on bcom.dfp.galleryCount
      var slidesWithAds = [];
      for ( var i = 0; i < slides.length; i++ ) {
        if ( i > 0 && i % bcom.dfp.galleryCount === 0 && scrollAds.count < scrollAds.max ) {
          scrollAds.count++;
          var adObject = {
            adName: 'ad_gallery' + scrollAds.count,
            adSize: [[300,250]],
            pos: ['atf', 'gallery' + scrollAds.count],
          };
          scrollAds.allAds.push(adObject);
          slidesWithAds.push(adObject);
        }
        slidesWithAds.push(slides[i]);
      }
      return slidesWithAds;
    },
    show: function() {
      if ( !scrollAds.displayed ) {
        scrollAds.define();
        scrollAds.display();
      }
    },
    define: function() {
      var networkCode = bcom.dfp.networkCode;
      var adUnit = bcom.dfp.adUnit;
      $.each(scrollAds.allAds, function( i, adObject ) {
        googletag.cmd.push(function() {
          adObject.adDefinition = googletag.defineSlot('/' + networkCode + '/' + adUnit, adObject.adSize, adObject.adName)
            .addService(googletag.pubads())
            .setTargeting("pos", adObject.pos);
        });
      });
    },
    display: function() {
      var definitionArray = [];
      var currentBreakPoint = bcom.util.getCurrentBreakPoint();
        googletag.cmd.push(function() {
          $.each(scrollAds.allAds, function( i, adObject ) {
            googletag.pubads().setTargeting( 'breakpoint', currentBreakPoint );
            googletag.display( adObject.adName );
            //definitionArray.push( adObject.adDefinition );
          });
        });
      // googletag.cmd.push(function() {
      //   googletag.pubads().setTargeting( 'breakpoint', currentBreakPoint );
      //   googletag.pubads().refresh( definitionArray );
      // });
      scrollAds.displayed = true;
    }
  };

	return module;
}());

//initing
$(function(){
	//check if there's a gallery on the page, if not, die
	// TODO: The following checks are both done in the module.init so this makes this a bit redundant. The gallery-wrapper length check is on line ~275 and payload is the first thing in module.init. Now, the payload check in the init is checking the lenght of payload, not if its undefined so there is some difference but this could be done much much better.
	if ($('.gallery-wrapper').length > 0 && payload != 'undefined'){
		bcom.galleries.init(payload);
	}
});
